<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whako Run Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Bangers&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            font-family: 'Inter', sans-serif;
            color: #333;
        }

        .game-container {
            position: relative;
            background: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet); /* Initial gradient for effect */
            background-size: 400% 400%; /* For smooth gradient animation */
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center; /* Centers children horizontally */
            padding: 20px;
            box-sizing: border-box;
            max-width: 90%; /* Responsive width */
            width: 800px; /* Max width for desktop */
            animation: rainbowBackground 15s ease infinite; /* Rainbow RGB animation */
        }

        @keyframes rainbowBackground {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .game-title {
            font-family: 'Bangers', cursive; /* Fun font for the title */
            font-size: 2.5em;
            font-weight: 700;
            color: #004d40; /* Darker teal for title */
            margin-bottom: 15px;
            text-align: center;
            width: 100%;
        }

        .whako-text {
            font-size: 1.3em; /* 30% larger than parent font-size */
        }

        canvas {
            background-color: #87ceeb; /* Sky blue background */
            border: 2px solid #00bcd4;
            border-radius: 10px;
            display: block;
            width: 100%; /* Canvas takes full width of container */
            height: 300px; /* Fixed height for game area */
            margin-bottom: 20px;
            z-index: 2; /* Ensure canvas is above paw prints */
        }

        .score-display {
            font-size: 1.8em;
            font-weight: 700;
            color: #00796b;
            margin-bottom: 15px;
            text-align: center; /* Center the score text */
            width: 100%;
            z-index: 2; /* Ensure score is above paw prints */
        }

        .start-screen,
        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 2.5em;
            font-weight: 700;
            border-radius: 15px;
            z-index: 10;
            text-align: center;
        }

        .start-screen p,
        .game-over-screen p {
            margin: 10px 0;
        }

        .start-button,
        .restart-button {
            background-color: #4caf50;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1.2em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            margin-top: 20px;
        }

        .start-button:hover,
        .restart-button:hover {
            background-color: #43a047;
            transform: translateY(-2px);
        }

        .start-button:active,
        .restart-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .whako-rewards {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1.2em;
            font-weight: 700;
            color: #00796b;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 5; /* Ensure it's above canvas but below game over screen */
        }

        .coming-soon-label {
            background-color: #e53935; /* Red color */
            color: white;
            font-size: 0.7em;
            padding: 4px 8px;
            border-radius: 5px;
            text-transform: uppercase;
            font-weight: bold;
        }

        /* Animated Paw Prints */
        .paw-print {
            position: absolute;
            width: 60px; /* 50% bigger (40 * 1.5 = 60) */
            height: 60px; /* 50% bigger (40 * 1.5 = 60) */
            background-color: rgba(150, 150, 150, 0.2); /* Faint gray */
            border-radius: 50% 50% 30% 30% / 50% 50% 70% 70%; /* Simplified paw shape */
            opacity: 0;
            animation: pawFade 8s infinite ease-out; /* Animation duration and loop */
            z-index: 1; /* Below game elements, above container background */
            transform: rotate(var(--rotation, 0deg)); /* Allow random rotation */
        }

        @keyframes pawFade {
            0% { opacity: 0; transform: scale(1.2) translateY(0px) rotate(var(--rotation, 0deg)); } /* 0.8 * 1.5 = 1.2 */
            20% { opacity: 0.15; transform: scale(1.5) translateY(-5px) rotate(var(--rotation, 0deg)); } /* 1 * 1.5 = 1.5 */
            80% { opacity: 0.15; transform: scale(1.5) translateY(-5px) rotate(var(--rotation, 0deg)); } /* 1 * 1.5 = 1.5 */
            100% { opacity: 0; transform: scale(1.2) translateY(0px) rotate(var(--rotation, 0deg)); } /* 0.8 * 1.5 = 1.2 */
        }


        /* Responsive adjustments */
        @media (max-width: 600px) {
            .game-container {
                padding: 15px;
                max-width: 95%;
            }

            .game-title {
                font-size: 2em;
                margin-bottom: 10px;
            }

            canvas {
                height: 250px;
            }

            .score-display {
                font-size: 1.5em;
                margin-bottom: 10px;
            }

            .whako-rewards {
                top: 10px;
                right: 10px;
                font-size: 1em;
                flex-direction: column;
                align-items: flex-end;
                gap: 5px;
            }

            .coming-soon-label {
                font-size: 0.6em;
                padding: 3px 6px;
            }

            .game-over-screen {
                font-size: 2em;
            }

            .restart-button {
                padding: 10px 20px;
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="whako-rewards">
            Whako Rewards <span class="coming-soon-label">Coming Soon!</span>
        </div>
        <h1 class="game-title"><span class="whako-text">Whako</span> Run Game</h1>
        <div class="score-display">
            <span>Score: <span id="score">0</span></span>
        </div>
        <canvas id="gameCanvas"></canvas>

        <!-- Start Screen -->
        <div id="startScreen" class="start-screen">
            <p>Welcome to Whako Run!</p>
            <button id="startButton" class="start-button">Start Game</button>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="game-over-screen" style="display: none;">
            <p>Game Over!</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button id="restartButton" class="restart-button">Restart Game</button>
        </div>

        <!-- Animated Paw Prints -->
        <div class="paw-print" style="top: 10%; left: 5%; animation-delay: 0s; --rotation: 15deg;"></div>
        <div class="paw-print" style="top: 30%; left: 20%; animation-delay: 1.5s; --rotation: -10deg;"></div>
        <div class="paw-print" style="top: 60%; left: 10%; animation-delay: 3s; --rotation: 25deg;"></div>
        <div class="paw-print" style="top: 20%; right: 15%; animation-delay: 4.5s; --rotation: -5deg;"></div>
        <div class="paw-print" style="top: 45%; right: 5%; animation-delay: 6s; --rotation: 20deg;"></div>
        <div class="paw-print" style="top: 70%; right: 25%; animation-delay: 7.5s; --rotation: -15deg;"></div>
        <div class="paw-print" style="top: 50%; left: 40%; animation-delay: 2s; --rotation: 0deg;"></div>
        <div class="paw-print" style="top: 80%; left: 60%; animation-delay: 5s; --rotation: 30deg;"></div>
        <div class="paw-print" style="top: 15%; left: 70%; animation-delay: 0.5s; --rotation: -20deg;"></div>
        <div class="paw-print" style="top: 35%; left: 85%; animation-delay: 3.5s; --rotation: 10deg;"></div>
    </div>

    <script>
        // Get the canvas and its 2D rendering context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Get score and game over display elements
        const scoreDisplay = document.getElementById('score');
        const finalScoreDisplay = document.getElementById('finalScore');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const restartButton = document.getElementById('restartButton');
        const startScreen = document.getElementById('startScreen'); // New: Start screen element
        const startButton = document.getElementById('startButton');   // New: Start button element

        // Game configuration variables
        const groundHeight = 20; // Height of the ground line
        let gameSpeed = 6.0984; // Initial speed of obstacles and collectables
        const maxGameSpeed = 20; // Maximum speed the game can reach
        const initialGameSpeedIncrement = 0.0002; // Slower increment at lower scores
        const speedBoostScoreThreshold = 100; // Score at which speed increase accelerates
        let score = 0;           // Current overall score (time-based)
        let miceCollected = 0;   // Internal variable for mice collected count (still tracked)
        let isGameOver = false;  // Game over flag
        let animationFrameId;    // To store the requestAnimationFrame ID for cancellation
        let gameStarted = false; // New: Flag to track if the game has started

        // Obstacle image loading
        const boxImage = new Image();
        boxImage.src = 'https://i.imgur.com/wSgszwn.png'; // New image URL
        let isBoxImageLoaded = false;

        // Fallback placeholder image for box in case the main image fails to load
        const placeholderBoxImage = new Image();
        placeholderBoxImage.src = 'https://placehold.co/48x48/D2B48C/8B4513?text=BOX'; 
        let isPlaceholderBoxImageLoaded = false;

        boxImage.onload = () => {
            isBoxImageLoaded = true;
        };
        boxImage.onerror = () => {
            console.warn('Failed to load box image. Using placeholder.');
            isBoxImageLoaded = false; // Ensure we don't try to use the broken image
            placeholderBoxImage.onload = () => { // Load placeholder if main image fails
                isPlaceholderBoxImageLoaded = true;
            };
            placeholderBoxImage.onerror = () => {
                console.error('Failed to load placeholder box image.');
            };
            placeholderBoxImage.src = 'https://placehold.co/48x48/D2B48C/8B4513?text=ERROR'; // Fallback for placeholder too
        };

        // Player image loading
        const playerImage = new Image();
        playerImage.src = 'https://i.imgur.com/7LtCGtI.png'; // Player image URL
        let isPlayerImageLoaded = false;

        // Fallback placeholder image for player in case the main image fails to load
        const placeholderPlayerImage = new Image();
        placeholderPlayerImage.src = 'https://placehold.co/48x48/4CAF50/FFFFFF?text=REX'; // Placeholder for Rex
        let isPlaceholderPlayerImageLoaded = false;

        playerImage.onload = () => {
            isPlayerImageLoaded = true;
        };
        playerImage.onerror = () => {
            console.warn('Failed to load player image. Using placeholder.');
            isPlayerImageLoaded = false; // Ensure we don't try to use the broken image
            placeholderPlayerImage.onload = () => { // Load placeholder if main image fails
                isPlaceholderPlayerImageLoaded = true;
            };
            placeholderPlayerImage.onerror = () => {
                console.error('Failed to load placeholder player image.');
            };
            placeholderPlayerImage.src = 'https://placehold.co/48x48/4CAF50/FFFFFF?text=ERROR'; // Fallback for placeholder too
        };

        // Coin image loading
        const coinImage = new Image();
        coinImage.src = 'https://i.imgur.com/OX8AxNN.png'; // NEW Coin image URL
        let isCoinImageLoaded = false;

        // Fallback placeholder image for coin
        const placeholderCoinImage = new Image();
        placeholderCoinImage.src = 'https://placehold.co/20x20/FFD700/000000?text=C'; // Placeholder for coin
        let isPlaceholderCoinImageLoaded = false;

        coinImage.onload = () => {
            isCoinImageLoaded = true;
        };
        coinImage.onerror = () => {
            console.warn('Failed to load coin image. Using placeholder.');
            isCoinImageLoaded = false;
            placeholderCoinImage.onload = () => {
                isPlaceholderCoinImageLoaded = true;
            };
            placeholderCoinImage.onerror = () => {
                console.error('Failed to load placeholder coin image.');
            };
            placeholderCoinImage.src = 'https://placehold.co/20x20/FFD700/000000?text=X'; // Fallback for placeholder too
        };


        // Rex (Player) properties
        const rex = {
            x: 50,
            y: canvas.height - groundHeight - 48, // Initial Y position above ground, adjusted for new height
            width: 48, // Set to 48 for 1:1 format
            height: 48, // Set to 48 for 1:1 format
            velocityY: 0,
            isJumping: false,
            // Draw Rex using the loaded image or a fallback
            draw: function() {
                ctx.save();
                ctx.translate(this.x, this.y);

                let imageToDraw = null;
                if (isPlayerImageLoaded) {
                    imageToDraw = playerImage;
                } else if (isPlaceholderPlayerImageLoaded) {
                    imageToDraw = placeholderPlayerImage;
                }

                if (imageToDraw) {
                    // Apply horizontal flip transformation
                    ctx.scale(-1, 1);
                    ctx.drawImage(imageToDraw, -this.width, 0, this.width, this.height);
                } else {
                    // Fallback to drawing a simple rectangle if no image is loaded
                    ctx.fillStyle = '#4CAF50'; // Green
                    ctx.beginPath();
                    ctx.roundRect(0, 0, this.width, this.height, 8);
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                ctx.restore();
            },
            // Update Rex's position during jump
            update: function() {
                // Apply gravity
                this.y += this.velocityY;
                this.velocityY += 0.8; // Gravity effect

                let onSolidSurface = false; // Flag to check if Rex is on ground or a platform

                // Check for collision with platforms first
                platforms.forEach(platform => {
                    // Check if Rex is falling and his next position would land him on this platform
                    if (this.velocityY >= 0 && // Only check if falling or stationary vertically
                        this.x < platform.x + platform.width &&
                        this.x + this.width > platform.x &&
                        this.y + this.height <= platform.y && // Rex's bottom is currently above or at platform's top
                        this.y + this.height + this.velocityY >= platform.y) { // Rex will land on or pass through platform top next frame
                        
                        this.y = platform.y - this.height; // Snap Rex to top of platform
                        this.isJumping = false;
                        this.velocityY = 0;
                        onSolidSurface = true;
                    }
                    // Check for collision with bottom of platform (hitting head while jumping up)
                    else if (this.velocityY < 0 && // Only check if moving upwards
                             this.x < platform.x + platform.width &&
                             this.x + this.width > platform.x &&
                             this.y >= platform.y + platform.height && // Rex's top is currently below or at platform's bottom
                             this.y + this.velocityY <= platform.y + platform.height) { // Rex's head will hit platform bottom next frame
                        
                        this.y = platform.y + platform.height; // Snap Rex to bottom of platform
                        this.velocityY = 0; // Stop upward movement, start falling
                    }
                });

                // If not landed on a platform, check for ground collision
                if (!onSolidSurface && this.y >= canvas.height - groundHeight - this.height) {
                    this.y = canvas.height - groundHeight - this.height;
                    this.isJumping = false;
                    this.velocityY = 0;
                    onSolidSurface = true; // Landed on ground
                }

                // If Rex is not on any solid surface (ground or platform) and is in the air, he is jumping/falling
                if (!onSolidSurface) {
                    this.isJumping = true;
                }
            },
            // Make Rex jump
            jump: function() {
                // Rex can only jump if he is NOT currently jumping (i.e., on ground or platform)
                if (!this.isJumping) {
                    this.isJumping = true;
                    this.velocityY = -14.85; // Initial jump velocity
                }
            }
        };

        // Obstacle properties and management
        let obstacles = [];
        const obstacleMinGap = 400; // Minimum gap between obstacles
        const obstacleMaxGap = 800; // Maximum gap between obstacles

        class Obstacle {
            constructor(x, y, width, height, type = 'cactus') { // Added type parameter
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type; // Store the type of obstacle
            }
            // Draw obstacle based on its type
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.strokeStyle = '#689F38'; // Darker green border
                ctx.lineWidth = 2;

                switch (this.type) {
                    case 'cactus':
                        ctx.fillStyle = '#8BC34A'; // Light green for cacti
                        // Main body
                        ctx.beginPath();
                        ctx.roundRect(0, 0, this.width, this.height, 5);
                        ctx.fill();
                        ctx.stroke();

                        // Small branches (simplified)
                        ctx.beginPath();
                        ctx.roundRect(this.width * 0.7, 0, this.width * 0.3, this.height * 0.4, 3);
                        ctx.roundRect(this.width * 0.1, this.height * 0.5, this.width * 0.3, this.height * 0.3, 3);
                        ctx.fill();
                        ctx.stroke();
                        break;
                    case 'rock': // This will now draw the image
                        let imageToDraw = null;
                        if (isBoxImageLoaded) {
                            imageToDraw = boxImage;
                        } else if (isPlaceholderBoxImageLoaded) {
                            imageToDraw = placeholderBoxImage;
                        }

                        if (imageToDraw) {
                            // Draw the image, scaling it to fit the obstacle's width and height
                            ctx.drawImage(imageToDraw, 0, 0, this.width, this.height);
                        } else {
                            // Fallback to drawing a simple rectangle if no image is loaded
                            ctx.fillStyle = '#D2B48C'; // Cardboard brown
                            ctx.strokeStyle = '#8B4513'; // Darker brown for outlines
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.roundRect(0, 0, this.width, this.height, 5);
                            ctx.fill();
                            ctx.stroke();
                        }
                        break;
                    case 'bush':
                        ctx.fillStyle = '#558B2F'; // Darker green for bushes
                        // Bush shape (multiple rounded bumps)
                        ctx.beginPath();
                        ctx.arc(this.width * 0.3, this.height * 0.6, this.width * 0.3, 0, Math.PI * 2);
                        ctx.arc(this.width * 0.7, this.height * 0.5, this.width * 0.35, 0, Math.PI * 2);
                        ctx.arc(this.width * 0.5, this.height * 0.7, this.width * 0.25, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        break;
                }
                ctx.restore();
            }
            // Update obstacle position
            update() {
                this.x -= gameSpeed;
            }
        }

        // Collectable properties and management (mice and coins)
        let collectables = [];
        const collectableSize = 20; // General size for mouse and coin
        const collectableMinGap = 446;
        const collectableMaxGap = 1389;
        let lastCollectableX = 0;

        class Collectable {
            constructor(x, y, size, type) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.type = type;
            }
            // Draw collectable based on its type (mouse or coin)
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                switch (this.type) {
                    case 'mouse':
                        ctx.fillStyle = '#9E9E9E'; // Gray for mouse
                        ctx.strokeStyle = '#616161';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.roundRect(-this.size * 0.5, -this.size * 0.3, this.size, this.size * 0.6, 5);
                        ctx.fill();
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(this.size * 0.2, -this.size * 0.3, this.size * 0.2, 0, Math.PI * 2);
                        ctx.arc(-this.size * 0.2, -this.size * 0.3, this.size * 0.2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = '#333';
                        ctx.beginPath();
                        ctx.arc(this.size * 0.4, 0, this.size * 0.05, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.moveTo(-this.size * 0.5, this.size * 0.1);
                        ctx.lineTo(-this.size * 0.8, this.size * 0.3);
                        ctx.strokeStyle = '#616161';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        break;
                    case 'coin':
                        let imageToDraw = null;
                        if (isCoinImageLoaded) {
                            imageToDraw = coinImage;
                        } else if (isPlaceholderCoinImageLoaded) {
                            imageToDraw = placeholderCoinImage;
                        }

                        if (imageToDraw) {
                            // Draw the image, scaling it to fit the collectable's width and height (1:1)
                            ctx.drawImage(imageToDraw, -this.size / 2, -this.size / 2, this.size, this.size);
                        } else {
                            // Fallback to drawing a simple circle if no image is loaded
                            ctx.fillStyle = '#FFD700'; // Gold color for coin
                            ctx.strokeStyle = '#DAA520'; // Darker gold border
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                        }
                        break;
                }
                ctx.restore();
            }
            // Update collectable position
            update() {
                this.x -= gameSpeed;
            }
        }

        // Platform properties and management
        let platforms = [];
        const platformMinGap = 600; // Minimum horizontal gap between platforms
        const platformMaxGap = 1200; // Maximum horizontal gap between platforms
        const platformMinHeight = 80; // Minimum height from ground for platforms
        const platformMaxHeight = 150; // Maximum height from ground for platforms
        const platformMinWidth = 80; // Minimum width of platforms
        const platformMaxWidth = 150; // Maximum width of platforms

        class Platform {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }
            draw() {
                ctx.fillStyle = '#66BB6A'; /* Grass green for platforms */
                ctx.strokeStyle = '#388E3C'; /* Darker green border */
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(this.x, this.y, this.width, this.height, 5);
                ctx.fill();
                ctx.stroke();
            }
            update() {
                this.x -= gameSpeed;
            }
        }

        // Cloud properties and management
        let clouds = [];
        const maxClouds = 5; // Maximum number of clouds
        const cloudMinSpeed = 0.5; // Minimum cloud speed
        const cloudMaxSpeed = 1.5; // Maximum cloud speed

        class Cloud {
            constructor(x, y, width, height, speed) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
            }

            draw() {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; // White with some transparency
                ctx.beginPath();
                // Main body of the cloud (simplified as a series of arcs)
                ctx.arc(this.x, this.y, this.width * 0.3, 0, Math.PI * 2);
                ctx.arc(this.x + this.width * 0.4, this.y, this.width * 0.35, 0, Math.PI * 2);
                ctx.arc(this.x - this.width * 0.4, this.y, this.width * 0.3, 0, Math.PI * 2);
                ctx.arc(this.x + this.width * 0.2, this.y - this.height * 0.3, this.width * 0.25, 0, Math.PI * 2);
                ctx.arc(this.x - this.width * 0.2, this.y - this.height * 0.3, this.width * 0.25, 0, Math.PI * 2);
                ctx.fill();
            }

            update() {
                this.x -= this.speed;
                // If cloud goes off-screen, reset its position to the right
                if (this.x + this.width < 0) {
                    this.x = canvas.width + getRandomInt(0, 200); // Appear off-screen to the right
                    this.y = getRandomInt(20, canvas.height / 2 - 50); // Random height in upper half
                    this.width = getRandomInt(80, 150);
                    this.height = getRandomInt(30, 60);
                    this.speed = getRandomFloat(cloudMinSpeed, cloudMaxSpeed);
                }
            }
        }

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function getRandomFloat(min, max) {
            return Math.random() * (max - min) + min;
        }

        // Function to initialize clouds
        function initializeClouds() {
            clouds = [];
            for (let i = 0; i < maxClouds; i++) {
                clouds.push(new Cloud(
                    getRandomInt(0, canvas.width), // Random x position
                    getRandomInt(20, canvas.height / 2 - 50), // Random y position in upper half
                    getRandomInt(80, 150), // Random width
                    getRandomInt(30, 60), // Random height
                    getRandomFloat(cloudMinSpeed, cloudMaxSpeed) // Random speed
                ));
            }
        }

        // Function to draw the ground
        function drawGround() {
            ctx.fillStyle = '#4CAF50'; /* Darker grass green for ground */
            ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
            ctx.strokeStyle = '#2E7D32'; /* Even darker green for ground line */
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - groundHeight);
            ctx.lineTo(canvas.width, canvas.height - groundHeight);
            ctx.stroke();
        }

        // Function to check for collision between two rectangles
        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.height > obj2.y;
        }

        // Function to check for collision between a rectangle and a circle (used for collectables)
        function checkCircleRectCollision(circle, rect) {
            // For simplicity, we'll treat the collectable as a circle with its center at (circle.x, circle.y)
            // and a radius of circle.size / 2 for collision detection.
            // The rect is Rex.

            // Find the closest point on the rectangle to the center of the circle
            let testX = circle.x;
            let testY = circle.y;

            if (circle.x < rect.x) {
                testX = rect.x;
            } else if (circle.x > rect.x + rect.width) {
                testX = rect.x + rect.width;
            }

            if (circle.y < rect.y) {
                testY = rect.y;
            } else if (circle.y > rect.y + rect.height) {
                testY = rect.y + rect.height;
            }

            // Calculate the distance between the closest point and the circle's center
            let distX = circle.x - testX;
            let distY = circle.y - testY;
            let distance = Math.sqrt((distX * distX) + (distY * distY));

            // Check if the distance is less than the circle's radius
            return distance <= circle.size / 2; // Use half of collectableSize as radius
        }

        // Game loop
        function animate() {
            if (isGameOver) {
                cancelAnimationFrame(animationFrameId); // Stop the game loop
                return;
            }

            // Clear the canvas for the next frame
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update and draw clouds
            clouds.forEach(cloud => {
                cloud.update();
                cloud.draw();
            });

            // Draw ground
            drawGround();

            // Update and draw Rex
            rex.update();
            rex.draw();

            // Generate and manage obstacles
            if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - getRandomInt(obstacleMinGap, obstacleMaxGap)) {
                const obstacleTypes = ['cactus', 'rock', 'bush']; // 'rock' now represents paper box
                const randomType = obstacleTypes[getRandomInt(0, obstacleTypes.length - 1)];

                let obstacleSize; // Use a single size for 1:1 aspect ratio
                let obstacleY;

                switch (randomType) {
                    case 'cactus':
                        obstacleSize = getRandomInt(30, 60); // Height for cactus
                        obstacleY = canvas.height - groundHeight - obstacleSize; // Ground level
                        break;
                    case 'rock': // Paper box dimensions (1:1 format)
                        obstacleSize = getRandomInt(40, 64); // Size for 1:1 box
                        obstacleY = canvas.height - groundHeight - obstacleSize; // Always ground level for boxes
                        break;
                    case 'bush':
                        obstacleSize = getRandomInt(30, 50); // Height for bush
                        obstacleY = canvas.height - groundHeight - obstacleSize; // Ground level
                        break;
                }

                // For cactus and bush, width is also determined by their specific drawing logic,
                // but for 'rock' (image), we enforce 1:1 with obstacleSize.
                let obstacleWidth = obstacleSize;
                let obstacleHeight = obstacleSize;

                if (randomType === 'cactus') {
                    obstacleWidth = getRandomInt(20, 40); // Cactus has its own width range
                    obstacleHeight = obstacleSize;
                } else if (randomType === 'bush') {
                    obstacleWidth = getRandomInt(40, 70); // Bush has its own width range
                    obstacleHeight = obstacleSize;
                }


                obstacles.push(new Obstacle(canvas.width, obstacleY, obstacleWidth, obstacleHeight, randomType));
            }

            const nextObstacles = [];
            obstacles.forEach(obstacle => {
                obstacle.update();
                obstacle.draw();
                if (checkCollision(rex, obstacle)) {
                    isGameOver = true;
                    showGameOverScreen();
                }
                // Keep obstacle if it's still visible or within a generous buffer off-screen
                if (obstacle.x + obstacle.width > -200) {
                    nextObstacles.push(obstacle);
                }
            });
            obstacles = nextObstacles; // Update the obstacles array


            // Generate and manage collectables (mice and coins)
            if (collectables.length === 0 || collectables[collectables.length - 1].x < canvas.width - getRandomInt(collectableMinGap, collectableMaxGap)) {
                const collectableTypes = ['mouse', 'coin']; // Now includes both mice and coins
                const randomCollectableType = collectableTypes[getRandomInt(0, collectableTypes.length - 1)];
                const collectableY = getRandomInt(canvas.height - groundHeight - 100, canvas.height - groundHeight - 50);
                collectables.push(new Collectable(canvas.width, collectableY, collectableSize, randomCollectableType));
                lastCollectableX = canvas.width;
            }

            const nextCollectables = [];
            collectables.forEach(collectable => {
                collectable.update();
                collectable.draw();
                if (checkCircleRectCollision(collectable, rex)) {
                    score += 10; // Still add 10 to overall score for any collectable
                    if (collectable.type === 'mouse') { // Only increment miceCollected for mice
                        miceCollected++; 
                    }
                } else { // Only add to nextCollectables if not collected
                    // Keep collectable if it's still visible or within a generous buffer off-screen
                    if (collectable.x + collectable.size > -200) {
                        nextCollectables.push(collectable);
                    }
                }
            });
            collectables = nextCollectables; // Update the collectables array


            // Generate and manage platforms
            if (platforms.length === 0 || platforms[platforms.length - 1].x < canvas.width - getRandomInt(platformMinGap, platformMaxGap)) {
                const platformWidth = getRandomInt(platformMinWidth, platformMaxWidth);
                const platformHeight = 20; // Fixed height for platforms
                const platformY = canvas.height - groundHeight - getRandomInt(platformMinHeight, platformMaxHeight);
                platforms.push(new Platform(canvas.width, platformY, platformWidth, platformHeight));
            }

            const nextPlatforms = [];
            platforms.forEach(platform => {
                platform.update();
                platform.draw();
                // Keep platform if it's still visible or within a generous buffer off-screen
                if (platform.x + platform.width > -200) {
                    nextPlatforms.push(platform);
                }
            });
            platforms = nextPlatforms; // Update the platforms array


            // Increase score over time
            score += 0.1;
            scoreDisplay.textContent = Math.floor(score); // Update overall score display

            // Increase game speed gradually, but cap it
            if (gameSpeed < maxGameSpeed) {
                if (score >= speedBoostScoreThreshold) {
                    gameSpeed += fastGameSpeedIncrement;
                } else {
                    gameSpeed += initialGameSpeedIncrement;
                }
            }

            animationFrameId = requestAnimationFrame(animate);
        }

        // Function to show game over screen
        function showGameOverScreen() {
            finalScoreDisplay.textContent = Math.floor(score);
            gameOverScreen.style.display = 'flex';
            gameStarted = false; // Game is no longer running
        }

        // Function to reset game state
        function resetGame() {
            rex.y = canvas.height - groundHeight - rex.height;
            rex.isJumping = false;
            rex.velocityY = 0;
            obstacles = [];
            collectables = [];
            platforms = []; // Reset platforms array
            score = 0;
            miceCollected = 0; // Reset mice collected count (internal)
            scoreDisplay.textContent = 0;
            gameSpeed = 6.0984; // Reset speed to initial value
            isGameOver = false;
            gameOverScreen.style.display = 'none';
            lastCollectableX = 0;
            initializeClouds(); // Re-initialize clouds on reset
            // Do not call animate() here, it will be called by startGame()
        }

        // New: Function to start the game
        function startGame() {
            if (!gameStarted) {
                gameStarted = true;
                startScreen.style.display = 'none'; // Hide start screen
                resetGame(); // Reset game state and then start animation
                animate();
            }
        }

        // Event listener for jump (spacebar or up arrow)
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space' || event.code === 'ArrowUp') {
                if (!isGameOver && gameStarted) { // Only jump if game started and not over
                    rex.jump();
                } else if (isGameOver) { // Restart if game is over
                    resetGame();
                    startGame(); // Call startGame to restart the animation loop
                } else if (!gameStarted) { // Start game if not started and space/up is pressed
                    startGame();
                }
            }
        });

        // Event listener for start button
        startButton.addEventListener('click', startGame);

        // Event listener for restart button
        restartButton.addEventListener('click', startGame); // Restart button now calls startGame

        // Initialize canvas dimensions on window load and resize
        function setCanvasDimensions() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            rex.y = canvas.height - groundHeight - rex.height;
        }

        // Initial setup when the window loads
        window.onload = function() {
            setCanvasDimensions();
            initializeClouds(); // Initialize clouds even before game starts, for visual on start screen
            // Do not call animate() here, it will be called by startGame()
        };

        // Adjust canvas dimensions on window resize
        window.addEventListener('resize', setCanvasDimensions);

    </script>
</body>
</html>
